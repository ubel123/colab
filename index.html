<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Bot (Matter.js)</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/matter-js/build/matter.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #loader, #end-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #333;
            font-size: 18px;
            transition: opacity 0.5s ease;
            text-align: center;
        }
        #end-screen {
            visibility: hidden;
            opacity: 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            margin-bottom: 16px;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="loader">
        <div class="spinner"></div>
        AI 모델 로딩 중...
    </div>
    <div id="end-screen">
        <p id="end-stats"></p>
        <p>3초 후 다시 시작합니다...</p>
    </div>
</div>

<script>
    // --- 1. 설정 및 초기화 ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('loader');
    const endScreen = document.getElementById('end-screen');
    const endStats = document.getElementById('end-stats');

    const gameWidth = 600;
    const gameHeight = 400;
    canvas.width = gameWidth;
    canvas.height = gameHeight;

    // 물리 상수
    const physical = {
        maxForce: 0.05, // Matter.js에 맞게 힘 스케일 조정
        maxAngle: 12 * (Math.PI / 180),
        dt: 1000 / 50, // ms 단위
    };

    // Matter.js 모듈
    const { Engine, World, Bodies, Body, Constraint, Composite } = Matter;

    // 물리 엔진 및 객체
    let engine;
    let cart, pole;

    // 게임 상태
    let stepCount = 0;
    let isGameOver = false;

    // ONNX 런타임 세션
    let session;
    let isModelReady = false;

    // --- 2. 물리 및 게임 상태 관리 ---
    function initPhysics() {
        engine = Engine.create();
        engine.world.gravity.y = 1.6; // Pymunk의 981과 유사한 효과를 내도록 튜닝
        engine.timing.delta = physical.dt;

        const cartW = 60, cartH = 30;
        const poleW = 8, poleLength = 120;
        const cartY = gameHeight - 120;

        // 카트
        cart = Bodies.rectangle(gameWidth / 2, cartY, cartW, cartH, {
            friction: 0.01,
            frictionAir: 0.01, // 마찰력
            density: 0.01, // cartMass 1.0과 유사하게
        });

        // 막대
        pole = Bodies.rectangle(gameWidth / 2, cartY - poleLength / 2, poleW, poleLength, {
            friction: 0,
            frictionAir: 0,
            density: 0.0005, // poleMass 0.1과 유사하게
        });

        // 조인트
        const joint = Constraint.create({
            bodyA: cart,
            bodyB: pole,
            pointA: { x: 0, y: -cartH / 2 },
            pointB: { x: 0, y: poleLength / 2 },
            stiffness: 1,
            length: 0
        });

        World.add(engine.world, [cart, pole, joint]);
    }

    function resetState() {
        if (!engine) initPhysics();

        // 기존 객체 제거 및 재생성
        World.clear(engine.world);
        initPhysics();

        // 초기 위치 및 속도 랜덤화
        const initialX = gameWidth / 2 + (Math.random() - 0.5) * 10;
        const initialAngle = (Math.random() - 0.5) * 0.1;

        Body.setPosition(cart, { x: initialX, y: cart.position.y });
        Body.setVelocity(cart, { x: (Math.random() - 0.5) * 5, y: 0 });
        Body.setAngle(pole, initialAngle);
        Body.setAngularVelocity(pole, (Math.random() - 0.5) * 0.2);

        stepCount = 0;
        isGameOver = false;
        endScreen.style.visibility = 'hidden';
        endScreen.style.opacity = '0';
    }

    // --- 4. AI 연동 ---
    function getObservation() {
        const obs = new Float32Array(4);
        const clip = (val, min, max) => Math.max(min, Math.min(val, max));

        // 1. 정규화된 카트 위치
        obs[0] = (cart.position.x - gameWidth / 2) / (gameWidth / 2);
        // 2. 정규화된 카트 속도 (스케일 조정)
        obs[1] = clip(cart.velocity.x / 15.0, -1.0, 1.0);
        // 3. 정규화된 막대 각도
        obs[2] = clip(pole.angle / physical.maxAngle, -1.0, 1.0);
        // 4. 정규화된 막대 각속도 (스케일 조정)
        obs[3] = clip(pole.angularVelocity / 2.0, -1.0, 1.0);

        return obs;
    }

    async function getAction(observation) {
        const tensor = new ort.Tensor('float32', observation, [1, 4]);
        const feeds = { 'observation': tensor };
        const results = await session.run(feeds);

        // 단일 값 (행동 인덱스) → Number 변환
        const action = Number(results.action.data[0]);
        return action;
    }

    // --- 5. 렌더링 ---
    function draw() {
        ctx.fillStyle = '#eef1f5';
        ctx.fillRect(0, 0, gameWidth, gameHeight);

        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(50, gameHeight - 120);
        ctx.lineTo(gameWidth - 50, gameHeight - 120);
        ctx.stroke();

        drawBody(cart, '#3498db');
        drawBody(pole, '#e74c3c');
    }

    function drawBody(body, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        body.vertices.forEach((v, i) => {
            if (i === 0) ctx.moveTo(v.x, v.y);
            else ctx.lineTo(v.x, v.y);
        });
        ctx.closePath();
        ctx.fill();
    }

    function showEndScreen(reward) {
        endStats.innerHTML = `스텝: ${stepCount}<br>보상: ${reward.toFixed(2)}`;
        endScreen.style.visibility = 'visible';
        endScreen.style.opacity = '1';
    }

    // --- 6. 게임 루프 ---
    async function gameLoop() {
        if (!isModelReady || isGameOver) {
            requestAnimationFrame(gameLoop);
            return;
        }

        stepCount++;

        const observation = getObservation();
        const actionIndex = await getAction(observation);
        let force = 0;
        if (actionIndex === 0) force = -physical.maxForce;
        if (actionIndex === 2) force = physical.maxForce;

        // 물리 업데이트
        Body.applyForce(cart, cart.position, { x: force, y: 0 });
        Engine.update(engine);

        // 카트 y축 및 회전 고정 (GrooveJoint 효과)
        Body.setPosition(cart, { x: cart.position.x, y: gameHeight - 120 });
        Body.setVelocity(cart, { x: cart.velocity.x, y: 0 });
        Body.setAngle(cart, 0);

        // 경계 처리
        if (cart.position.x < 50) Body.setPosition(cart, { x: 50, y: cart.position.y });
        if (cart.position.x > gameWidth - 50) Body.setPosition(cart, { x: gameWidth - 50, y: cart.position.y });

        draw();

        if (Math.abs(pole.angle) > physical.maxAngle) {
            isGameOver = true;
            showEndScreen(-1.0);
            setTimeout(() => {
                resetState();
                requestAnimationFrame(gameLoop);
            }, 3000);
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

    // --- 7. 메인 실행 함수 ---
    async function main() {
        try {
            session = await ort.InferenceSession.create('./ppo_js_balance_bot.onnx');
            isModelReady = true;
            console.log("ONNX 모델 로딩 및 세션 생성 완료.");
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.style.display = 'none';
                resetState();
                gameLoop();
            }, 500);
        } catch (e) {
            console.error(`모델 로딩 실패: ${e}`);
            loader.innerHTML = "AI 모델 로딩에 실패했습니다.<br>콘솔을 확인해주세요.";
        }
    }

    main();
</script>

</body>
</html>